1. Static Arrays:
    * Static arrays in SystemVerilog are arrays whose size and dimensions are fixed at compile time.
    * Once declared, their size cannot change during simulation.
    * They can be "packed" or "unpacked", depending on how the elements are arranged in memory.

    * Packed Arrays:
        . Elements are stored contiguously in memory, in a single continuous block without gaps.
        . They support bit-level operations, just like vectors.
        . The dimensions are declared "before" the identifier name.
        . Syntax examples:
            > <data_type> [data_width] array_name;
            > <data_type> [no_of_packs][data_width_of_each_pack] array_name;

    * Unpacked Arrays:
        . Elements may or may not be contiguous in memory and are stored as multiple rows.
        . They store multiple elements and are typically used to represent memory or collections of data.
        . The dimensions are declared "after" the identifier name.
        . Syntax examples:
            > <data_type> array_name [data_width];
            > <data_type> array_name [no_of_rows][no_of_columns];
            > <data_type> array_name [no_of_layers][no_of_rows][no_of_columns];

2. Dynamic Arrays:
    * Dynamic arrays in SystemVerilog are arrays whose size can be changed during simulation run-time.
    * Dynamic arrays are better suited for contiguous collections that grow or shrink during run-time.
    * To declare a dynamic array, we just provide an empty square brackets after the identifier name.
    * The size can be specified during run-time using: new[size].
    * Syntax examples:
        > <data_type> [data_width] array_name [];
        > array_name = new[4];
        > array_name = new[10];
        > array_name = new[10](array_name);

3. Associative Arrays:
    * Associative arrays in SystemVerilog are used to store data in a sparse manner.
    * Memory is allocated only when needed, unlike dynamic arrays where memory must be allocated beforehand.
    * The index type is not limited to integers, it can be of any data type, such as string, class, or even enum.
    * They act as "lookup tables", where each index serves as a unique key to access stored elements.
    * Associative arrays are ideal when the size of the data set is unknown or the data space is sparse.
    * Associative arrays handle scattered or key-based data efficiently.
    * Syntax examples:
        > <data_type> array_name [index_type];
        > int a_array_1 [*];                    // Associative array of integers (unspecified index)
        > bit [31:0] a_array_2 [string];        // Associative array of 32-bit elements, indexed by string
        > event ev_array [myClass];             // Associative array of events, indexed by class
